<h1 id="2-정렬">2. 정렬</h1>
<h2 id="1-정렬">1. 정렬</h2>
<p>특정한 값을 기준으로 데이터를 순서대로 배치하는 방법.</p>
<h3 id="구현-난이도는-쉽지만-속도는-느린-알고리즘">구현 난이도는 쉽지만 속도는 느린 알고리즘</h3>
<p>버블/ 삽입/ 선택 정렬</p>
<h3 id="구현-난이도는-조금-더-어렵지만-속도는-빠른-알고리즘">구현 난이도는 조금 더 어렵지만 속도는 빠른 알고리즘</h3>
<p>합병 / 힙 / 퀵 / 트리</p>
<h3 id="하디브리드-정렬">하디브리드 정렬</h3>
<p>팀 정렬 블록 병합정렬 인트로 정렬</p>
<h3 id="기타-정렬-알고리즘">기타 정렬 알고리즘</h3>
<p>기수 정렬, 카운팅 정렬 ,셸 정렬, 보고 정렬</p>
<h2 id="2-버블-정렬">2. 버블 정렬</h2>
<p>인접한 데이터를 비교하며 자리를 바꾸는 방식.
<img alt="" src="https://velog.velcdn.com/images/noop/post/af45c1b1-2cef-486a-86f3-943f4d29e7f1/image.png" /></p>
<h2 id="3-삽입-정렬">3. 삽입 정렬</h2>
<p>앞의 데이터를 정렬 해 가면서 삽입 위치를 찾아 정렬하는 방식</p>
<p><img alt="" src="https://velog.velcdn.com/images/noop/post/c8c2a8a1-7de7-4e6c-ae02-8d5654938e4f/image.png" /></p>
<h2 id="4-선택-정렬">4. 선택 정렬</h2>
<p>최소 혹은 최대값을 찾아서 가장 앞 또는 뒤부터 정렬하는 방식
<img alt="" src="https://velog.velcdn.com/images/noop/post/b76069d2-9d0b-435f-81d4-3ef82e83f03d/image.png" /></p>
<h2 id="5-합병정렬">5. 합병정렬</h2>
<p>배열을 계속 분할해서 길이가 1이 되도록 만들고, 인접한 부분끼리 정렬하면서 합병하는 방식.</p>
<h2 id="6-힙-정렬">6. 힙 정렬</h2>
<p>힙자료구조 형태의 정렬 방식
기존 배열을 최대 힙으로 구조 변경 후 정렬 진행</p>
<h2 id="7-퀵-정렬">7. 퀵 정렬</h2>
<p>임의의 기준 값을 정하고 그 값을 기준으로 좌우 분할아며 정렬하는 방식</p>
<h2 id="8-트리-정렬">8. 트리 정렬</h2>
<p>이진탐색트리를(BST) 만들어 정렬하는 방식</p>
<h2 id="9-기수정렬">9. 기수정렬</h2>
<p>낮은 자리 수 부터 정렬하는 방식
각 원소 간의 비교 연산을 하지 않아 빠른 대신, 기수 테이블을 위한 메모리 필요.
알고리즘 복잡도 : O(dn)</p>
<h2 id="10-계수정렬">10. 계수정렬</h2>
<p>숫자끼리 비교하지 않고 카운트를 세서 정렬하는 방식
카운팅을 위한 메모리 필요
알고리즘 복잡도 : O(n+k)</p>
<h2 id="11-셸정렬">11. 셸정렬</h2>
<p>삽입정렬의 약점을 보완한 정렬방식
삽입정렬의 약점</p>
<ul>
<li>오름차순 정렬기준, 내림차순으로 구성 된 데이터에 대해서는 앞의 데이터와 하나씩 비교하며 모두 교환 필요.
이전의 모든 데이터와 비교하지 않고 일정 간격을 두어 비교</li>
</ul>